/** @package */
/** @module crypto */
const {
  createCipheriv,
  createDecipheriv
} = require('crypto');
const utils = require('./utils');
const sha256 = require('./sha256');
const base64 = require('./base64');

module.exports.nameKeySizeHash = async(name, size, key) => {
  utils.assert_undef(name, 'name is undefined');
  utils.assert_undef(size, 'size is undefined');
  utils.assert_undef(key, 'key is undefined');
  utils.assert_buf(key, 'key is not an buffer');
  utils.assert_str(name, 'name is not a string');


  const key64 = base64.encode(key);
  const nkh = await sha256(Buffer.from(key64 + name + key64));
  const encr = `{n:${name}:s${size}:k${key64}}`;
  const sha = await sha256(Buffer.from(encr + nkh.toString('hex')));
  return sha.toString('hex') //return lowercase
}

/**
 * merges an buffer of key and iv to a combined buffer with version information
 *
 * @async
 * @function crypto.mergeKeyIv
 * @param {Buffer} key - the generated key from {@link #keygen}
 * @param {Buffer} iv - the generated key from {@link #keygen}
 * @example <caption>hello world</caption>
 * const key = CryptoLib.keygen();
 * const iv = CryptoLib.keygen();
 * const merged = await CryptoLib.crypto.mergeKeyIv(key, iv);
 * @return Buffer - the combined buffer of key&iv + version information
 */
module.exports.mergeKeyIv = (key, iv) => {
  let buf = Buffer.alloc(key.length + iv.length);
  let bufArr = [Buffer.alloc(1, 0x1)];
  for (let i = 0; i < buf.length; ++i) {
    let posInBuf = Math.floor(i / 2);
    let bit = (i % 2) ? key.slice(posInBuf, posInBuf + 1) : iv.slice(posInBuf, posInBuf + 1);
    bufArr.push(bit);
  }
  return Buffer.concat(bufArr);
};

/**
 * unmerges an buffer to its key,iv and version attributes
 *
 * @async
 * @function unmergeKeyIv
 * @param {Buffer} buf - the generated buffer from {@link #mergeKeyIv}
 * @example <caption>hello world</caption>
 * const key = CryptoLib.keygen();
 * const iv = CryptoLib.keygen();
 * const merged = await CryptoLib.crypto.mergeKeyIv(key, iv);
 *
 * const unmerged = await CryptoLib.crypto.unmergeKeyIf(merged);
 * // unmerged.key, unmerged.iv & unmerged.iv are of type Buffer
 * @return Buffer - the combined buffer of key&iv + version information
 */
module.exports.unmergeKeyIv = (buf) => {
  if (!!((buf.length - 1) % 2)) {
    throw new Error("wrong buf length");
  }
  let version = buf.slice(0, 1);
  buf = buf.slice(1, buf.length);
  let _key = [];
  let _iv = [];
  for (let i = 0; i < buf.length; ++i) {
    let bit = buf.slice(i, i + 1);
    (i % 2 ? _key.push(bit) : _iv.push(bit));
  }
  return {
    version: version,
    key: Buffer.concat(_key),
    iv: Buffer.concat(_iv)
  }
};

/**
 * encrypts an buffer using aes-128-cbc
 *
 * @async
 * @function encrypt
 * @param {Buffer} data - the data as buffer to be encrypted
 * @param {Buffer} key - the key generated by {@link keygen}
 * @param {Buffer} iv - the iv generated by {@link keygen}
 * @example <caption>hello world</caption>
 * const key = CryptoLib.keygen();
 * const iv = CryptoLib.keygen();
 * const data = Buffer.from("Hello World");
 * const encrypt = await CryptoLib.crypto.encrypt(data, key, iv);
 * @return Buffer - the encrypted data
 */
module.exports.encrypt = (data, key, iv = false) => {
  utils.assert_buf(data, 'data needs to be buffer');
  utils.assert_buf(key, 'key needs to be buffer');
  utils.assert_buf(iv, 'iv needs to be buffer');
  return new Promise(resolve => {
    const cipher = createCipheriv('aes-128-cbc', key, iv);
    let encrypted = [cipher.update(data)];
    encrypted.push(cipher.final());
    resolve(Buffer.concat(encrypted));
  });
}

/**
 * decrypts an buffer using aes-128-cbc
 *
 * @async
 * @function decrypt
 * @param {Buffer} data - the data as buffer to be decrypted
 * @param {Buffer} key - the key generated by {@link keygen}
 * @param {Buffer} iv - the iv generated by {@link keygen}
 * @example <caption>hello world</caption>
 * const key = CryptoLib.keygen();
 * const iv = CryptoLib.keygen();
 * const data = await CryptoLib.crypto.encrypt(Buffer.from("Hello World"), key, iv);
 * const encrypt = await CryptoLib.crypto.decrypt(data, key, iv);
 * @return Buffer - the encrypted data
 */
module.exports.decrypt = (data, key, iv) => {
  utils.assert_buf(data, 'data needs to be buffer');
  utils.assert_buf(key, 'key needs to be buffer');
  utils.assert_buf(iv, 'iv needs to be buffer');

  return new Promise(resolve => {
    let d = data.slice();
    const cipher = createDecipheriv('aes-128-cbc', key, iv);
    let encrypted = [cipher.update(d)];
    encrypted.push(cipher.final());
    resolve(Buffer.concat(encrypted));
  });
}