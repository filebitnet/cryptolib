var filebitCrypto;filebitCrypto=(()=>{var e={979:(e,t,r)=>{const{is_str:n,is_uint8:i,str_to_buffer:a,buffer_to_str:o,assert_uint8:s}=r(274);e.exports.encode=e=>{return n(e)&&(e=a(e)),t=function(e){s(e,"uint8toBase64 input needs to be uint8array");for(var t="",r=new Uint8Array(e),n=r.byteLength,i=0;i<n;i++)t+=String.fromCharCode(r[i]);return window.btoa(t)}(e),String(t).replace(/\+/gi,"-").replace(/\//gi,"_").replace(/=/gi,"");var t},e.exports.decode=(e,t=!0)=>(e=(e=>String(e).replace(/\-/gi,"+").replace(/_/gi,"/"))(e),t?function(e){for(var t=window.atob(e),r=t.length,n=new Uint8Array(r),i=0;i<r;i++)n[i]=t.charCodeAt(i);return n}(e):atob(e))},502:(e,t,r)=>{const n=r(274);e.exports.mergeKeyIv=(e,t)=>{n.assert_uint8(e,"key is not an uint8array"),n.assert_uint8(t,"iv is not an uint8array");const r=e.byteLength+t.byteLength;let i=new ArrayBuffer(e.byteLength+t.byteLength+1),a=new Uint8Array(i);const o=new DataView(e.buffer),s=new DataView(t.buffer);a[0]=1;for(let e=0;e<r;++e){let t=Math.floor(e/2),r=e%2?o.getUint8(t):s.getUint8(t);a[e+1]=r}return a},e.exports.unmergeKeyIv=e=>{if(n.assert_uint8(e,"buf is not an uint8array"),(e.byteLength-1)%2)throw new Error("unmergeKeyIv buf is invalid length is: "+e.byteLength);let t=new DataView(e.buffer);const r=t.getUint8(0),i=e.byteLength-1,a=new Uint8Array(i/2),o=new Uint8Array(i/2);for(let e=0;e<i;++e){let r=t.getUint8(1+e),n=Math.floor(e/2);e%2?a[n]=r:o[n]=r}return{version:r,key:a,iv:o}}},500:(e,t,r)=>{const{mergeKeyIv:n,unmergeKeyIv:i}=r(502),a=r(979),o=r(274),s=r(65);e.exports.unmergeKeyIv=i,e.exports.mergeKeyIv=n,e.exports.nameKeySizeHash=async(e,t,r)=>{o.assert_undef(e,"name is undefined"),o.assert_undef(t,"size is undefined"),o.assert_undef(r,"key is undefined"),o.assert_uint8(r,"key is not an uint8array"),a.encode(r);const n=await s(o.str_to_uint8(r+e+r)),i=`{n:${e}:s${t}:k${r}`,u=await s(o.str_to_uint8(i+o.uint8_to_hex(n,!0)));return o.uint8_to_hex(u,!0)},e.exports.encrypt=(e,t,r)=>new Promise((async n=>{o.assert_uint8(e,"data needs to be an uint8array"),o.assert_uint8(t,"key needs to be an uint8array"),o.assert_uint8(r,"iv needs to be an uint8array");let i=await window.crypto.subtle.importKey("raw",new Uint8Array(t),{name:"AES-CBC"},!1,["encrypt"]),a=await window.crypto.subtle.encrypt({name:"AES-CBC",iv:new Uint8Array(r)},i,e);n(new Uint8Array(a))})),e.exports.decrypt=(e,t,r)=>new Promise((async n=>{o.assert_uint8(e,"data needs to be an uint8array"),o.assert_uint8(t,"key needs to be an uint8array"),o.assert_uint8(r,"iv needs to be an uint8array"),e=new Uint8Array(e),t=new Uint8Array(t),r=new Uint8Array(r);let i=await window.crypto.subtle.importKey("raw",new Uint8Array(t),{name:"AES-CBC"},!1,["decrypt"]),a=await window.crypto.subtle.decrypt({name:"AES-CBC",iv:r},i,new Uint8Array(e));n(new Uint8Array(a))}))},217:e=>{var t=function(e,t){for(e=e.toString(16).toUpperCase();e.length<t;)e="0"+e;return e};e.exports=function(e){var r=Math.ceil(e.length/16),n=e.length%16||16,i=e.length.toString(16).length;i<6&&(i=6);for(var a,o="Offset";o.length<i;)o+=" ";for(o="[36m"+o+"  ",a=0;a<16;a++)o+=" "+t(a,2);o+="[0m\n",e.length&&(o+="\n");var s,u,y,w=0;for(a=0;a<r;a++){var f;for(o+="[36m"+t(w,i)+"[0m  ",u=16-(s=a===r-1?n:16),f=0;f<s;f++)o+=" "+t(e[w],2),w++;for(f=0;f<u;f++)o+="   ";for(w-=s,o+="   ",f=0;f<s;f++)o+=(y=e[w])>31&&y<127||y>159?String.fromCharCode(y):".",w++;o+="\n"}console.log(o)}},751:e=>{e.exports=(e=128)=>{let t=e/8,r=new ArrayBuffer(t),n=new Uint8Array(r),i=new Uint8Array(t);window.crypto.getRandomValues(i);for(let e=0;e<=i.length;++e)n[e]=i[e];return n}},65:(e,t,r)=>{const n=r(274);e.exports=function(e){return new Promise((async t=>{n.assert_uint8(e,"input for sha256 needs to be uint8array");let r=await window.crypto.subtle.digest("SHA-256",e);return t(new Uint8Array(r))}))}},274:e=>{const t=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"],r=new Array(256);for(let e=0;e<256;e++)r[e]=`${t[e>>>4&15]}${t[15&e]}`;e.exports.uint8_to_hex=(e,t=!1)=>{n(e)&&(e=new Uint8Array(e));let i="";for(let t=0,n=e.length;t<n;t++)i+=r[e[t]];return t?i.toLowerCase():i},e.exports.str_to_uint8=e=>(new TextEncoder).encode(e),e.exports.uint8_to_str=e=>(new TextDecoder).decode(e);const n=e.exports.is_ab=e=>e instanceof ArrayBuffer,i=e.exports.is_str=e=>"string"==typeof e;e.exports.assert_str=(e,t="input is not an string")=>{if(!i(e))throw new Error(t)};const a=e.exports.is_uint8=e=>e instanceof Uint8Array;e.exports.assert_uint8=(e,t="input is not an uint8array")=>{if(!a(e))throw new Error(t)};const o=e.exports.is_undef=e=>void 0===e;e.exports.assert_undef=(e,t="input is undefined")=>{if(o(e))throw new Error(t)}},814:(e,t,r)=>{e.exports.keygen=r(751),e.exports.sha256=r(65),e.exports.hex=r(217),e.exports.base64=r(979),e.exports.crypto=r(500),e.exports.utils=r(274)}},t={};return function r(n){if(t[n])return t[n].exports;var i=t[n]={exports:{}};return e[n](i,i.exports,r),i.exports}(814)})();