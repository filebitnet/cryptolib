var filebitCrypto;filebitCrypto=(()=>{var e={979:(e,t,r)=>{const{is_str:n,is_uint8:a,str_to_buffer:s,buffer_to_str:i,assert_uint8:o}=r(274);e.exports.encode=e=>{return n(e)&&(e=s(e)),t=function(e){o(e,"uint8toBase64 input needs to be uint8array");for(var t="",r=new Uint8Array(e),n=r.byteLength,a=0;a<n;a++)t+=String.fromCharCode(r[a]);return btoa(t)}(e),String(t).replace(/\+/gi,"-").replace(/\//gi,"_").replace(/=/gi,"");var t},e.exports.decode=(e,t=!0)=>(e=(e=>String(e).replace(/\-/gi,"+").replace(/_/gi,"/"))(e),t?function(e){for(var t=atob(e),r=t.length,n=new Uint8Array(r),a=0;a<r;a++)n[a]=t.charCodeAt(a);return n}(e):atob(e))},502:(e,t,r)=>{const n=r(274);e.exports.mergeKeyIv=(e,t)=>{n.assert_uint8(e,"key is not an uint8array"),n.assert_uint8(t,"iv is not an uint8array");const r=e.byteLength+t.byteLength;let a=new ArrayBuffer(e.byteLength+t.byteLength+1),s=new Uint8Array(a);const i=new DataView(e.buffer),o=new DataView(t.buffer);s[0]=1;for(let e=0;e<r;++e){let t=Math.floor(e/2),r=e%2?i.getUint8(t):o.getUint8(t);s[e+1]=r}return s},e.exports.unmergeKeyIv=e=>{if(n.assert_uint8(e,"buf is not an uint8array"),(e.byteLength-1)%2)throw new Error("unmergeKeyIv buf is invalid length is: "+e.byteLength);let t=new DataView(e.buffer);const r=t.getUint8(0),a=e.byteLength-1,s=new Uint8Array(a/2),i=new Uint8Array(a/2);for(let e=0;e<a;++e){let r=t.getUint8(1+e),n=Math.floor(e/2);e%2?s[n]=r:i[n]=r}return{version:r,key:s,iv:i}}},500:(e,t,r)=>{const{mergeKeyIv:n,unmergeKeyIv:a}=r(502),s=r(979),i=r(274),o=r(65);e.exports.unmergeKeyIv=a,e.exports.mergeKeyIv=n,e.exports.nameKeySizeHash=async(e,t,r)=>{i.assert_undef(e,"name is undefined"),i.assert_undef(t,"size is undefined"),i.assert_undef(r,"key is undefined"),i.assert_uint8(r,"key is not an uint8array"),s.encode(r);const n=await o(i.str_to_uint8(r+e+r)),a=`{n:${e}:s${t}:k${r}`,u=await o(i.str_to_uint8(a+i.uint8_to_hex(n,!0)));return i.uint8_to_hex(u,!0)},e.exports.encrypt=(e,t,r)=>new Promise((async n=>{i.assert_uint8(e,"data needs to be an uint8array"),i.assert_uint8(t,"key needs to be an uint8array"),i.assert_uint8(r,"iv needs to be an uint8array");let a=await crypto.subtle.importKey("raw",new Uint8Array(t),{name:"AES-CBC"},!1,["encrypt"]),s=await crypto.subtle.encrypt({name:"AES-CBC",iv:new Uint8Array(r)},a,e);n(new Uint8Array(s))})),e.exports.decrypt=(e,t,r)=>new Promise((async n=>{i.assert_uint8(e,"data needs to be an uint8array"),i.assert_uint8(t,"key needs to be an uint8array"),i.assert_uint8(r,"iv needs to be an uint8array"),e=new Uint8Array(e),t=new Uint8Array(t),r=new Uint8Array(r);let a=await crypto.subtle.importKey("raw",new Uint8Array(t),{name:"AES-CBC"},!1,["decrypt"]),s=await crypto.subtle.decrypt({name:"AES-CBC",iv:r},a,new Uint8Array(e));n(new Uint8Array(s))}))},217:e=>{var t=function(e,t){for(e=e.toString(16).toUpperCase();e.length<t;)e="0"+e;return e};e.exports=function(e){var r=Math.ceil(e.length/16),n=e.length%16||16,a=e.length.toString(16).length;a<6&&(a=6);for(var s,i="Offset";i.length<a;)i+=" ";for(i="[36m"+i+"  ",s=0;s<16;s++)i+=" "+t(s,2);i+="[0m\n",e.length&&(i+="\n");var o,u,y,f=0;for(s=0;s<r;s++){var p;for(i+="[36m"+t(f,a)+"[0m  ",u=16-(o=s===r-1?n:16),p=0;p<o;p++)i+=" "+t(e[f],2),f++;for(p=0;p<u;p++)i+="   ";for(f-=o,i+="   ",p=0;p<o;p++)i+=(y=e[f])>31&&y<127||y>159?String.fromCharCode(y):".",f++;i+="\n"}console.log(i)}},751:e=>{e.exports=(e=128)=>{let t=e/8,r=new ArrayBuffer(t),n=new Uint8Array(r),a=new Uint8Array(t);window.crypto.getRandomValues(a);for(let e=0;e<=a.length;++e)n[e]=a[e];return n}},65:(e,t,r)=>{const n=r(274);e.exports=function(e){return new Promise((async t=>{n.assert_uint8(e,"input for sha256 needs to be uint8array");let r=await crypto.subtle.digest("SHA-256",e);return t(new Uint8Array(r))}))}},274:e=>{const t=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"],r=new Array(256);for(let e=0;e<256;e++)r[e]=`${t[e>>>4&15]}${t[15&e]}`;e.exports.uint8_to_hex=(e,t=!1)=>{n(e)&&(e=new Uint8Array(e));let a="";for(let t=0,n=e.length;t<n;t++)a+=r[e[t]];return t?a.toLowerCase():a},e.exports.str_to_uint8=e=>(new TextEncoder).encode(e),e.exports.uint8_to_str=e=>(new TextDecoder).decode(e);const n=e.exports.is_ab=e=>e instanceof ArrayBuffer;e.exports.assert_ab=(e,t="input is not an arraybuffer")=>{if(!n(e))throw new Error(t)};const a=e.exports.is_str=e=>"string"==typeof e;e.exports.assert_str=(e,t="input is not an string")=>{if(!a(e))throw new Error(t)};const s=e.exports.is_uint8=e=>e instanceof Uint8Array;e.exports.assert_uint8=(e,t="input is not an uint8array")=>{if(!s(e))throw new Error(t)};const i=e.exports.is_undef=e=>void 0===e;e.exports.assert_undef=(e,t="input is undefined")=>{if(i(e))throw new Error(t)}},814:(e,t,r)=>{e.exports.keygen=r(751),e.exports.sha256=r(65),e.exports.hex=r(217),e.exports.base64=r(979),e.exports.crypto=r(500),e.exports.utils=r(274)}},t={};return function r(n){if(t[n])return t[n].exports;var a=t[n]={exports:{}};return e[n](a,a.exports,r),a.exports}(814)})();