!function(e,t){if("object"==typeof exports&&"object"==typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var r=t();for(var n in r)("object"==typeof exports?exports:e)[n]=r[n]}}(self,(function(){return e={979:function(e,t,r){const{is_str:n,is_uint8:o,str_to_buffer:i,buffer_to_str:a,assert_uint8:s}=r(274);e.exports.encode=e=>{return n(e)&&(e=i(e)),t=function(e){s(e,"uint8toBase64 input needs to be uint8array");for(var t="",r=new Uint8Array(e),n=r.byteLength,o=0;o<n;o++)t+=String.fromCharCode(r[o]);return btoa(t)}(e),String(t).replace(/\+/gi,"-").replace(/\//gi,"_").replace(/=/gi,"");var t},e.exports.decode=(e,t=!0)=>(e=(e=>String(e).replace(/\-/gi,"+").replace(/_/gi,"/"))(e),t?function(e){for(var t=atob(e),r=t.length,n=new Uint8Array(r),o=0;o<r;o++)n[o]=t.charCodeAt(o);return n}(e):atob(e))},502:function(e,t,r){const n=r(274);e.exports.mergeKeyIv=(e,t)=>{n.assert_uint8(e,"key is not an uint8array"),n.assert_uint8(t,"iv is not an uint8array");const r=e.byteLength+t.byteLength;let o=new ArrayBuffer(e.byteLength+t.byteLength+1),i=new Uint8Array(o);const a=new DataView(e.buffer),s=new DataView(t.buffer);i[0]=1;for(let e=0;e<r;++e){let t=Math.floor(e/2),r=e%2?a.getUint8(t):s.getUint8(t);i[e+1]=r}return i},e.exports.unmergeKeyIv=e=>{if(n.assert_uint8(e,"buf is not an uint8array"),(e.byteLength-1)%2)throw new Error("unmergeKeyIv buf is invalid length is: "+e.byteLength);let t=new DataView(e.buffer);const r=t.getUint8(0),o=e.byteLength-1,i=new Uint8Array(o/2),a=new Uint8Array(o/2);for(let e=0;e<o;++e){let r=t.getUint8(1+e),n=Math.floor(e/2);e%2?i[n]=r:a[n]=r}return{version:r,key:i,iv:a}}},500:function(e,t,r){const{mergeKeyIv:n,unmergeKeyIv:o}=r(502),i=r(979),a=r(274),s=r(65);e.exports.unmergeKeyIv=o,e.exports.mergeKeyIv=n,e.exports.nameKeySizeHash=async(e,t,r)=>{a.assert_undef(e,"name is undefined"),a.assert_undef(t,"size is undefined"),a.assert_undef(r,"key is undefined"),a.assert_uint8(r,"key is not an uint8array"),i.encode(r);const n=await s(a.str_to_uint8(r+e+r)),o=`{n:${e}:s${t}:k${r}`,u=await s(a.str_to_uint8(o+a.uint8_to_hex(n,!0)));return a.uint8_to_hex(u,!0)},e.exports.encrypt=(e,t,r)=>new Promise((async n=>{a.assert_uint8(e,"data needs to be an uint8array"),a.assert_uint8(t,"key needs to be an uint8array"),a.assert_uint8(r,"iv needs to be an uint8array");let o=await crypto.subtle.importKey("raw",new Uint8Array(t),{name:"AES-CBC"},!1,["encrypt"]),i=await crypto.subtle.encrypt({name:"AES-CBC",iv:new Uint8Array(r)},o,e);n(new Uint8Array(i))})),e.exports.decrypt=(e,t,r)=>new Promise((async n=>{a.assert_uint8(e,"data needs to be an uint8array"),a.assert_uint8(t,"key needs to be an uint8array"),a.assert_uint8(r,"iv needs to be an uint8array"),e=new Uint8Array(e),t=new Uint8Array(t),r=new Uint8Array(r);let o=await crypto.subtle.importKey("raw",new Uint8Array(t),{name:"AES-CBC"},!1,["decrypt"]),i=await crypto.subtle.decrypt({name:"AES-CBC",iv:r},o,new Uint8Array(e));n(new Uint8Array(i))}))},217:function(e){var t=function(e,t){for(e=e.toString(16).toUpperCase();e.length<t;)e="0"+e;return e};e.exports=function(e){var r=Math.ceil(e.length/16),n=e.length%16||16,o=e.length.toString(16).length;o<6&&(o=6);for(var i,a="Offset";a.length<o;)a+=" ";for(a="[36m"+a+"  ",i=0;i<16;i++)a+=" "+t(i,2);a+="[0m\n",e.length&&(a+="\n");var s,u,f,y=0;for(i=0;i<r;i++){var p;for(a+="[36m"+t(y,o)+"[0m  ",u=16-(s=i===r-1?n:16),p=0;p<s;p++)a+=" "+t(e[y],2),y++;for(p=0;p<u;p++)a+="   ";for(y-=s,a+="   ",p=0;p<s;p++)a+=(f=e[y])>31&&f<127||f>159?String.fromCharCode(f):".",y++;a+="\n"}console.log(a)}},751:function(e){e.exports=(e=128)=>{let t=e/8,r=new ArrayBuffer(t),n=new Uint8Array(r),o=new Uint8Array(t);window.crypto.getRandomValues(o);for(let e=0;e<=o.length;++e)n[e]=o[e];return n}},65:function(e,t,r){const n=r(274);e.exports=function(e){return new Promise((async t=>{n.assert_uint8(e,"input for sha256 needs to be uint8array");let r=await crypto.subtle.digest("SHA-256",e);return t(new Uint8Array(r))}))}},274:function(e){const t=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"],r=new Array(256);for(let e=0;e<256;e++)r[e]=`${t[e>>>4&15]}${t[15&e]}`;e.exports.uint8_to_hex=(e,t=!1)=>{n(e)&&(e=new Uint8Array(e));let o="";for(let t=0,n=e.length;t<n;t++)o+=r[e[t]];return t?o.toLowerCase():o},e.exports.str_to_uint8=e=>(new TextEncoder).encode(e),e.exports.uint8_to_str=e=>(new TextDecoder).decode(e);const n=e.exports.is_ab=e=>e instanceof ArrayBuffer;e.exports.assert_ab=(e,t="input is not an arraybuffer")=>{if(!n(e))throw new Error(t)};const o=e.exports.is_str=e=>"string"==typeof e;e.exports.assert_str=(e,t="input is not an string")=>{if(!o(e))throw new Error(t)};const i=e.exports.is_uint8=e=>e instanceof Uint8Array;e.exports.assert_uint8=(e,t="input is not an uint8array")=>{if(!i(e))throw new Error(t)};const a=e.exports.is_undef=e=>void 0===e;e.exports.assert_undef=(e,t="input is undefined")=>{if(a(e))throw new Error(t)}},814:function(e,t,r){e.exports.keygen=r(751),e.exports.sha256=r(65),e.exports.hex=r(217),e.exports.base64=r(979),e.exports.crypto=r(500),e.exports.utils=r(274)}},t={},function r(n){if(t[n])return t[n].exports;var o=t[n]={exports:{}};return e[n](o,o.exports,r),o.exports}(814);var e,t}));